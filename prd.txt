这份 PRD（产品需求文档）是基于你提供的截图界面逻辑，并结合新增的“水印功能”需求整理而成的。你可以直接拿这份文档与开发人员（前端/后端）进行沟通，或者自己作为开发蓝本。

产品需求文档 (PRD) - 图片字幕与水印生成工具

Project Name: Image Subtitle & Watermark Generator
Version: v1.0
Status: Draft
Date: 2023-10-27

1. 项目背景与目标 (Project Background & Objectives)
1.1 背景

当前社交媒体上流行“电影台词拼接”或“长截图”风格的图片。用户希望能够方便地为一张静态图片添加多行对话字幕，或者为原创图片添加水印以保护版权。

1.2 目标

开发一个基于 Web 的轻量级工具，允许用户：

上传本地图片。

自定义字幕的样式（大小、颜色、高度、描边）并生成类似电影截图的效果。

新增功能：支持添加文字或图片水印，自定义水印位置和透明度。

实时/点击生成预览，并支持下载合成后的图片。

2. 用户流程 (User Flow)

上传: 用户选择或拖拽图片进入编辑区。

字幕配置: 用户输入多行文本，设置字体大小、颜色、描边及行高。

水印配置: 用户开启水印选项，输入水印文字/上传水印图，调整透明度及位置。

生成: 点击“生成”按钮，Canvas 渲染合成图。

保存: 用户查看效果满意后，点击“保存”下载图片。

3. 功能需求详情 (Functional Requirements)
3.1 图片上传模块 (Image Upload)

输入方式:

点击按钮“选择文件”触发系统文件选择器。

支持拖拽图片到指定区域（可选）。

格式支持: JPG, PNG, WEBP。

交互: 上传成功后，显示原文件名（如截图中的 61bca...png），并在预览区重置/显示该图片。

3.2 字幕编辑模块 (Subtitle Editor) - 参考截图

该模块用于控制图片底部文字的渲染逻辑。

字段/功能	类型	默认值	说明
字幕高度 (px)	Input (Number)	40	每一行字幕所占据的垂直高度区域。
字体大小 (px)	Input (Number)	20	文字的像素大小。
字体颜色	Input (Color Picker)	#FFFFFF (白)	支持色盘选择或 Hex 值输入。
轮廓颜色	Input (Color Picker)	#000000 (黑)	文字描边颜色，用于增加对比度。
字幕内容输入框	Textarea	空	多行文本输入。逻辑： 每一行文字对应生成图片底部的一行字幕。

渲染逻辑 (核心):

字幕区域通常位于图片底部。

模式 A（覆盖模式 - 截图效果）: 文字直接覆盖在原图底部，背景需添加半透明黑色遮罩以突出文字。

模式 B（拼接模式 - 经典电影长图）: （建议作为进阶选项，虽然截图未明确体现，但通常此类工具都需要）。保留原图，在下方通过增加 Canvas 高度来绘制纯黑/模糊背景并在其上绘制文字。

本次 MVP 按照截图逻辑: 文字绘制在图片底部区域，支持自动换行或手动换行（Textarea 的每一行对应画面上的一行）。

3.3 水印编辑模块 (Watermark Editor) - 新增需求

该模块为独立的功能区，可折叠或平铺在字幕设置下方。

字段/功能	类型	说明
水印类型	Radio Button	选项：文字水印 / 图片水印。
水印内容	Input / File	文字模式输入文本；图片模式上传 Logo。
大小/缩放	Slider / Input	控制水印的大小（文字字号或图片缩放比例）。
透明度	Slider (0-100%)	控制水印的不透明度（Opacity）。
位置	Grid Select / XY	提供九宫格选择（左上、右上、居中、右下等），或自定义 XY 坐标。建议默认右下角。
水印颜色	Color Picker	仅针对文字水印有效。
3.4 预览与操作模块 (Action & Preview)

生成字幕图片 (Button):

点击后触发 Canvas 绘图逻辑。

顺序：绘制底图 -> 绘制字幕背景(可选) -> 绘制字幕文字 -> 绘制水印。

在页面下方 <img> 标签中渲染 Base64 结果。

保存图片 (Button):

将生成的 Canvas 内容导出为 PNG/JPG 并触发浏览器下载行为。

预览区:

展示合成后的效果图（参考截图中下方的大图）。

4. 界面布局 (UI Layout)

参考截图风格，采用 “上控制，下预览” 或 “左控制，右预览” 的布局。

顶部/左侧控制栏结构：

标题: 图片字幕生成器

文件操作区: [选择文件按钮] [文件名显示]

参数设置区 (Flex 布局):

[字幕高度] [字体大小]

[字体颜色] [轮廓颜色]

文本输入区: 大文本框 (Placeholder: "请输入字幕，每行对应一句...")

水印设置区 (新增):

[水印开关/Tab]

[内容输入] [位置选择] [透明度滑块]

操作按钮: [生成字幕图片] [保存图片] (绿色主色调)

底部/右侧展示区：

预览容器: 包含生成的最终图片，宽度自适应，保持原图比例。

版权/说明: 底部 Footer (如截图中的公众号信息，可做成默认水印示例)。

5. 技术实现建议 (Technical Stack)

前端框架: 原生 HTML/JS 即可，或使用 Vue.js / React 方便状态管理。

核心技术: HTML5 <canvas> API。

ctx.drawImage(): 绘制底图。

ctx.fillText() & ctx.strokeText(): 绘制带描边的文字。

ctx.globalAlpha: 控制水印透明度。

计算逻辑:

字幕位置: y = ImageHeight - (TotalLines - CurrentLineIndex) * SubtitleHeight - PaddingBottom。

文字居中: x = ImageWidth / 2, textAlign = 'center'.

6. 边缘情况 (Edge Cases)

文字过长: 如果一行文字超过图片宽度，需要处理自动换行，或者自动缩小字号（建议 MVP 版本先做截断或自动换行）。

图片未上传: 点击生成时提示“请先上传图片”。

图片尺寸过大: 前端处理 4K 以上图片可能会卡顿，建议限制最大分辨率或在 Canvas 中进行压缩处理。

字体加载: 确保 Canvas 能使用通用字体（sans-serif），避免中文乱码。

附：Canvas 绘图伪代码 (供开发参考)
code
JavaScript
download
content_copy
expand_less
function generateImage() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // 1. 设置 Canvas 尺寸等于原图尺寸
    canvas.width = img.width;
    canvas.height = img.height;

    // 2. 绘制原图
    ctx.drawImage(img, 0, 0);

    // 3. 绘制字幕
    const lines = textArea.value.split('\n');
    ctx.font = `${fontSize}px sans-serif`;
    ctx.fillStyle = fontColor;
    ctx.strokeStyle = outlineColor;
    ctx.textAlign = 'center';
    ctx.lineWidth = 3;

    // 从底部向上计算起始位置 (参考截图效果，文字浮在图片底部)
    // 或者从底部特定区域开始画
    let startY = canvas.height - (lines.length * lineHeight) - 20; // 20px padding

    lines.forEach((line, index) => {
        const y = startY + (index * lineHeight);
        const x = canvas.width / 2;
        
        // 绘制描边
        ctx.strokeText(line, x, y);
        // 绘制实心字
        ctx.fillText(line, x, y);
    });

    // 4. 绘制水印 (新增功能)
    if (watermarkEnabled) {
        ctx.globalAlpha = watermarkOpacity; // 设置透明度 0.0 - 1.0
        ctx.font = `${watermarkSize}px sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        
        // 简单的右下角定位算法
        const wmX = canvas.width - ctx.measureText(watermarkText).width - 20;
        const wmY = canvas.height - 20;
        
        ctx.fillText(watermarkText, wmX, wmY);
    }

    // 5. 输出
    resultImage.src = canvas.toDataURL('image/png');
}